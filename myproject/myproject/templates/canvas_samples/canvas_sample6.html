{% load staticfiles %}
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>

<script type="text/javascript" src="{% static "js/three.js" %}"></script>
<script type="text/javascript" src="{% static "js/OrbitControls.js" %}"></script>

<script type="text/javascript" src="{% static "model/Coefficients.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Wall.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Floor.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Plan.js" %}"></script>

<script type="text/javascript">

    //globals
    var mesh;

    function initialize() {
        document.body.style.backgroundColor = '#cccccc';

        setupThreeJS();
        setupWorld();
        setupEvents();

        //looping
        requestAnimationFrame(function animate() {
            renderer.render(scene, camera);
            controls.update(clock.getDelta());
            requestAnimationFrame(animate);
        });
    }

    function setupWorld() {

        //FLOOR
        var geo = new THREE.PlaneGeometry(unitLength, unitLength, resolution, resolution);
        {#        var mat = new THREE.MeshPhongMaterial({color: 0x9db3b5, overdraw: true, wireframe: true});#}
        var mat = new THREE.MeshBasicMaterial({color: 0xffffff});
        mesh = new THREE.Mesh(geo, mat);
        mesh.material.side = THREE.DoubleSide;

        mesh.rotation.x = -90 * Math.PI / 180;
        mesh.receiveShadow = true;
        scene.add(mesh);


        //GRID
        var gridMat = new THREE.LineBasicMaterial({color: 0x000000});

        for (var i = 0; i < resolution; i++) {
            for (var j = 0; j < resolution; j++) {
                var lineGeom = new THREE.Geometry();
                lineGeom.vertices.push(new THREE.Vector3(i * unitSize - unitLength / 2.0, 10, -unitLength / 2.0));
                lineGeom.vertices.push(new THREE.Vector3(i * unitSize - unitLength / 2.0, 10, unitLength / 2.0));

                var line = new THREE.Line(lineGeom, gridMat);
                scene.add(line);

                lineGeom = new THREE.Geometry();
                lineGeom.vertices.push(new THREE.Vector3(-unitLength / 2.0, 10, j * unitSize - unitLength / 2.0));
                lineGeom.vertices.push(new THREE.Vector3(unitLength / 2.0, 10, j * unitSize - unitLength / 2.0));

                line = new THREE.Line(lineGeom, gridMat);
                scene.add(line);

            }
        }

        var entities = new THREE.Geometry();

        var geometryData = {{ geomData | safe }};

        var plan = new Plan(geometryData);
        plan.create(entities);

        var model = new THREE.Mesh(entities,new THREE.MeshFaceMaterial(Wall.materialList.concat(Floor.materialList)));
        scene.add(model);

        //LIGHT
        var light = new THREE.DirectionalLight(0xf9f1c2, 1);
        light.position.set(10000, 10000, 10000);
        light.castShadow = true;
        light.shadowMapWidth = 2048;
        light.shadowMapHeight = 2048;
        var d = 1000;
        light.shadowCameraLeft = d;
        light.shadowCameraRight = -d;
        light.shadowCameraTop = d;
        light.shadowCameraBottom = -d;
        light.shadowCameraFar = 40000;
        scene.add(light);

    }

    function setupThreeJS() {

        scene = new THREE.Scene();
        {#        scene.fog = new THREE.FogExp2(0x9db3b5, 0.0004);#}
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 50000);
        camera.position.y = 10000;
        camera.position.z = 10000;
        camera.rotation.x = -45 * Math.PI / 180;

        clock = new THREE.Clock();
        controls = new THREE.OrbitControls(camera);


        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;
        document.body.appendChild(renderer.domElement);

        projector = new THREE.Projector();
    }

    function setupEvents() {
        renderer.domElement.addEventListener('mousemove', function (event) {

            event.preventDefault();

            var vector = new THREE.Vector3(
                    renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
                    -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
                    0
            );

            projector.unprojectVector(vector, camera);

            var raycaster = new THREE.Raycaster(
                    camera.position,
                    vector.sub(camera.position).normalize()
            );

            var intersects = raycaster.intersectObject(mesh);
            if (intersects.length) {
                var vec = intersects[0].point;
                console.log(vec);
            } else {

            }
        });


        renderer.domElement.addEventListener('mousedown', function (event) {
            event.preventDefault();

        });

    }

    initialize();

</script>

</body>
</html>