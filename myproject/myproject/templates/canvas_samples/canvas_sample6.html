{% load staticfiles %}
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>

<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>


<script type="text/javascript" src="{% static "js/three.js" %}"></script>
<script type="text/javascript" src="{% static "js/tween.min.js" %}"></script>
<script type="text/javascript" src="{% static "js/OrbitControls.js" %}"></script>

<script type="text/javascript" src="{% static "model/Coefficients.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Axis.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Wall.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Floor.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Plan.js" %}"></script>

<form id="my_form" action="" method="post">
    {% csrf_token %}
    <input type="hidden" id="image" name="image" value="--">
{#    <input type="submit" value="Send">#}
</form>

<div id="result"></div>


<script type="text/javascript">

//globals

var frameNo = 0;
var plans = [];
var geometryData, root;

function initialize() {
    document.body.style.backgroundColor = '#cccccc';

    setupThreeJS();
    setupWorld();
    setupTween();
    setupEvents();

    //console.log(canvas.toDataURL().replace("data:image/png;base64,", ""));

    //looping
    requestAnimationFrame(function animate() {
        renderer.render(scene, camera);
        controls.update(clock.getDelta());
        frameNo++;
        if (frameNo < 100) {
            console.log(frameNo);
            $.post("",
                    {
                        frame:zeroAdd(frameNo),
                        image: renderer.domElement.toDataURL().replace("data:image/png;base64,", ""),
                        csrfmiddlewaretoken: '{{ csrf_token}}'},

                    function (data, status) {
                        $("#result").html(data);
                    }
            )
                    .fail(function (xhr) {
                        console.log("Error: " + xhr.statusText);
                        alert("Error: " + xhr.statusText);
                    });
        }

        //TWEEN.update();
        requestAnimationFrame(animate);
    });
}

function setupThreeJS() {

    var CANVAS_WIDTH = window.innerWidth;
    var CANVAS_HEIGHT = window.innerHeight;
    CANVAS_WIDTH = 1920;
    CANVAS_HEIGHT = 1080;

    geometryData = [];
    {% for p in geomData %} geometryData.push({{ p.geometry | safe }});
    {% endfor %}

    root = Math.ceil(Math.sqrt(geometryData.length));

    scene = new THREE.Scene();
    {#        scene.fog = new THREE.FogExp2(0x9db3b5, 0.0004);#}
    camera = new THREE.PerspectiveCamera(50, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 50000000);
    {#        camera.position.y = (root * (unitLength + 250)) / 2.0;#}
    {#        camera.position.z = (root * (unitLength + 250)) / 2.0;#}
    {#        camera.rotation.x = -45 * Math.PI / 180;#}

    camera.position.x = (root * (unitLength + 250));
    camera.position.y = (root * (unitLength + 250));
    camera.position.z = (root * (unitLength + 250));

    clock = new THREE.Clock();
    controls = new THREE.OrbitControls(camera);
    controls.target = new THREE.Vector3(
            (root * (unitLength + 250)) / 2.0,
            0.0,
            (root * (unitLength + 250)) / 2.0
    );

    renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true});
    //renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
    renderer.shadowMapEnabled = true;
    canvas = document.body.appendChild(renderer.domElement);
    {#    canvas = $("#canvas");#}
    {#    canvas = renderer.domElement;#}
    {#    canvas.id = "canvas";#}

    projector = new THREE.Projector();


}

function setupWorld() {

    for (var j = 0; j < Math.pow(root, 2); j++) {

        if (j > geometryData.length - 1) break;
        //console.log(j);
        var plan = new Plan(
                geometryData[j],
                j % root * (unitLength + 250),
                Math.floor(j / root) * (unitLength + 250)
        );

        plan.createEntity();

        plans.push(plan);
    }


    {#    var plan;#}
    {#    var entities = new THREE.Geometry();#}
    {##}
    {#    for (var j = 0; j < Math.pow(root, 2); j++) {#}
    {#        //0. declare plan#}
    {##}
    {#        if (j > geometryData.length - 1) break;#}
    {#        console.log(j);#}
    {#        plan = new Plan(#}
    {#                geometryData[j],#}
    {#                j % root * (unitLength + 250),#}
    {#                Math.floor(j / root) * (unitLength + 250)#}
    {#        );#}
    {##}
    {#        //1.planes#}
    {#        plan.createPlane(entities);#}
    {#        //var planes = new THREE.Mesh(planeEntities, Plan.planeMat);#}
    {#        //scene.add(planes);#}
    {##}
    {#        //2.grid#}
    {#        //plan.createGrid();#}
    {##}
    {#        //3.walls and floors#}
    {#        plan.create(entities);#}
    {#        entities.computeFaceNormals();#}
    {##}
    {#        plans.push(plan);#}
    {##}
    {#    }#}
    {#    entities.computeFaceNormals();#}
    {#    var model = new THREE.Mesh(entities, Plan.materialList);#}
    {#    model.matrixAutoUpdate = false;#}
    {#    model.updateMatrix();#}
    {#    model.castShadow = true;#}
    {#    model.recieveShadow = true;#}
    {#    scene.add(model);#}

    //////////////////////////////////////////////////////////////////////////////////////
    // light
    //////////////////////////////////////////////////////////////////////////////////////

    var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;

    var ambient = new THREE.AmbientLight(0x8f9fa3);
    scene.add(ambient);

    var light = new THREE.DirectionalLight(0xf9f1c2, 1);
    light.position.set(10000, 10000, 10000);
    light.castShadow = true;
    light.shadowMapWidth = SHADOW_MAP_WIDTH;
    light.shadowMapHeight = SHADOW_MAP_HEIGHT;
    var d = 1000;
    light.shadowCameraLeft = d;
    light.shadowCameraRight = -d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;
    light.shadowCameraFar = 40000;
    scene.add(light);

    {#    light = new THREE.SpotLight(0xffffff, 1, 0, Math.PI, 1.0);#}
    {#    light.position.set(25000, 40000, 25000);#}
    {#    light.target.position.set(0, 0, 0);#}
    {##}
    {#    light.castShadow = true;#}
    {##}
    {#    light.shadowCameraNear = 7000;#}
    {#    light.shadowCameraFar = camera.far;#}
    {#    light.shadowCameraFov = 80;#}
    {##}
    {#    //light.shadowCameraVisible = true;#}
    {##}
    {#    light.shadowBias = 0.000001;#}
    {#    light.shadowDarkness = 0.2;#}
    {##}
    {#    light.shadowMapWidth = SHADOW_MAP_WIDTH;#}
    {#    light.shadowMapHeight = SHADOW_MAP_HEIGHT;#}

    scene.add(light);


    /////////////////////////////////////////////////////////////////////////////////////////
    // axis
    /////////////////////////////////////////////////////////////////////////////////////////
    var axis = new Axis(100000, 10);
    axis.create();

}

function setupTween() {

    {#        var target = [];#}
    var position, target;
    var tweenPosition = [], tweenTarget = [];
    var segment = 600;

    for (var i = 0; i < geometryData.length; i++) {

        target = new THREE.Vector3(
                i % root * (unitLength + 250),
                0.0,
                Math.floor(i / root) * (unitLength + 250)
        );

        position = new THREE.Vector3(
                target.x + unitLength,
                unitLength * 2,
                target.z + unitLength
        );

        {#        position = new THREE.Vector3(#}
        {#                Math.floor(Math.random() * root) * unitLength,#}
        {#                unitLength * 2,#}
        {#                Math.floor(Math.random() * root) * unitLength#}
        {#        );#}

        var tempTweenPosition = new TWEEN.Tween(camera.position)
                .to({
                    x: position.x,
                    y: position.y,
                    z: position.z
                }, segment)
                .delay(segment)
                .easing(TWEEN.Easing.Sinusoidal.InOut);

        var tempTweenTarget = new TWEEN.Tween(controls.target)
                .to({
                    x: target.x,
                    y: target.y,
                    z: target.z
                }, segment)
                .delay(segment)
                .easing(TWEEN.Easing.Sinusoidal.InOut);

        tweenTarget.push(tempTweenTarget);
        tweenPosition.push(tempTweenPosition);
    }

    for (var i = 0; i < geometryData.length - 1; i++) {
        tweenTarget[i].chain(tweenTarget[i + 1]);
        tweenPosition[i].chain(tweenPosition[i + 1]);
    }


    tweenTarget[0].start();
    tweenPosition[0].start();

}


function setupEvents() {
    renderer.domElement.addEventListener('mousemove', function (event) {

        event.preventDefault();

        var vector = new THREE.Vector3(
                renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
                -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
                0
        );

        projector.unprojectVector(vector, camera);

        var raycaster = new THREE.Raycaster(
                camera.position,
                vector.sub(camera.position).normalize()
        );

        {#            var intersects = raycaster.intersectObject(mesh);#}
        {#            if (intersects.length) {#}
        {#                var vec = intersects[0].point;#}
        {#                console.log(vec);#}
        {#            } else {#}
        {##}
        {#            }#}
    });


    renderer.domElement.addEventListener('mousedown', function (event) {

        //event.preventDefault();

        console.log(camera.position);
        console.log(controls.target);
        //console.log(renderer.domElement.toDataURL().replace("data:image/png;base64,", ""));

        //$("#image").value = renderer.domElement.toDataURL().replace("data:image/png;base64,", "");

        console.log($("#image").value);


        $.post("",
                {
                    image: renderer.domElement.toDataURL().replace("data:image/png;base64,", ""),
                    csrfmiddlewaretoken: '{{ csrf_token}}'},

                function (data, status) {
                    $("#result").html(data);
                }
        )
                .fail(function (xhr) {
                    console.log("Error: " + xhr.statusText);
                    alert("Error: " + xhr.statusText);
                });

        for (var i = 0; i < plans.length; i++) {
            //plans[i].toggleVisible();
            //console.log(plans[i].visible);
        }

    });

}

initialize();

</script>

</body>
</html>