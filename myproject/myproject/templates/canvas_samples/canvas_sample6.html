{% load staticfiles %}
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>

<script type="text/javascript" src="{% static "js/three.js" %}"></script>
<script type="text/javascript" src="{% static "js/tween.min.js" %}"></script>
<script type="text/javascript" src="{% static "js/OrbitControls.js" %}"></script>

<script type="text/javascript" src="{% static "model/Coefficients.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Axis.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Wall.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Floor.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Plan.js" %}"></script>

<script type="text/javascript">

    //globals
    var planes;

    var geometryData, root;

    function initialize() {
        document.body.style.backgroundColor = '#cccccc';

        setupThreeJS();
        setupWorld();
        setupTween();
        setupEvents();

        //looping
        requestAnimationFrame(function animate() {
            renderer.render(scene, camera);
            controls.update(clock.getDelta());
            TWEEN.update();
            requestAnimationFrame(animate);
        });
    }

    function setupThreeJS() {

        geometryData = [];
        {% for p in geomData %} geometryData.push({{ p.geometry | safe }});
        {% endfor %}

        root = Math.ceil(Math.sqrt(geometryData.length));

        scene = new THREE.Scene();
        {#        scene.fog = new THREE.FogExp2(0x9db3b5, 0.0004);#}
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 500000);
        {#        camera.position.y = (root * (unitLength + 250)) / 2.0;#}
        {#        camera.position.z = (root * (unitLength + 250)) / 2.0;#}
        {#        camera.rotation.x = -45 * Math.PI / 180;#}

        camera.position.x = (root * (unitLength + 250));
        camera.position.y = (root * (unitLength + 250));
        camera.position.z = (root * (unitLength + 250));


        clock = new THREE.Clock();
        controls = new THREE.OrbitControls(camera);
        controls.target = new THREE.Vector3(
                (root * (unitLength + 250)) / 2.0,
                0.0,
                (root * (unitLength + 250)) / 2.0
        );


        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;
        document.body.appendChild(renderer.domElement);

        projector = new THREE.Projector();
    }

    function setupWorld() {

        var plan;
        var entities = new THREE.Geometry();

        for (var j = 0; j < Math.pow(root, 2); j++) {
            //0. declare plan

            if (j > geometryData.length - 1) break;
            console.log(j);
            plan = new Plan(
                    geometryData[j],
                    j % root * (unitLength + 250),
                    Math.floor(j / root) * (unitLength + 250)
            );

            //1.planes
            plan.createPlane(entities);
            //var planes = new THREE.Mesh(planeEntities, Plan.planeMat);
            //scene.add(planes);

            //2.grid
            //plan.createGrid();

            //3.walls and floors
            plan.create(entities);
            var model = new THREE.Mesh(entities, Plan.materialList);
            scene.add(model);
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // light
        //////////////////////////////////////////////////////////////////////////////////////
        var light = new THREE.DirectionalLight(0xf9f1c2, 1);
        light.position.set(10000, 10000, 10000);
        light.castShadow = true;
        light.shadowMapWidth = 2048;
        light.shadowMapHeight = 2048;
        var d = 1000;
        light.shadowCameraLeft = d;
        light.shadowCameraRight = -d;
        light.shadowCameraTop = d;
        light.shadowCameraBottom = -d;
        light.shadowCameraFar = 40000;
        scene.add(light);


        /////////////////////////////////////////////////////////////////////////////////////////
        // axis
        /////////////////////////////////////////////////////////////////////////////////////////
        var axis = new Axis(100000, 10);
        axis.create();

    }

    function setupTween() {

{#        var target = [];#}
        var position,target;
        var tweenPosition= [],tweenTarget = [];
        var segment =600;

        for (var i = 0; i < geometryData.length; i++) {

            target = new THREE.Vector3(
                    i % root * (unitLength + 250),
                    0.0,
                    Math.floor(i / root) * (unitLength + 250)
            );

{#            position = new THREE.Vector3(#}
{#                    target.x + unitLength,#}
{#                    unitLength *2,#}
{#                    target.z + unitLength#}
{#            );#}

            position = new THREE.Vector3(
                    Math.floor(Math.random()*root)*unitLength,
                    unitLength*2,
                    Math.floor(Math.random()*root)*unitLength
            );

            var tempTweenPosition = new TWEEN.Tween(camera.position)
                    .to({
                        x:position.x,
                        y:position.y,
                        z:position.z
                    },segment)
                    .delay(segment)
                    .easing(TWEEN.Easing.Sinusoidal.InOut);

            var tempTweenTarget = new TWEEN.Tween(controls.target)
                    .to({
                        x:target.x,
                        y:target.y,
                        z:target.z
                    },segment)
                    .delay(segment)
                    .easing(TWEEN.Easing.Sinusoidal.InOut);

            tweenTarget.push(tempTweenTarget);
            tweenPosition.push(tempTweenPosition);
        }

        for(var i=0;i<geometryData.length-1;i++){
            tweenTarget[i].chain(tweenTarget[i+1]);
            tweenPosition[i].chain(tweenPosition[i+1]);
        }


        tweenTarget[0].start();
        tweenPosition[0].start();

    }


    function setupEvents() {
        renderer.domElement.addEventListener('mousemove', function (event) {

            event.preventDefault();

            var vector = new THREE.Vector3(
                    renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
                    -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
                    0
            );

            projector.unprojectVector(vector, camera);

            var raycaster = new THREE.Raycaster(
                    camera.position,
                    vector.sub(camera.position).normalize()
            );

            {#            var intersects = raycaster.intersectObject(mesh);#}
            {#            if (intersects.length) {#}
            {#                var vec = intersects[0].point;#}
            {#                console.log(vec);#}
            {#            } else {#}
            {##}
            {#            }#}
        });


        renderer.domElement.addEventListener('mousedown', function (event) {
            event.preventDefault();

            console.log(camera.position);
            console.log(controls.target);
        });

    }

    initialize();

</script>

</body>
</html>