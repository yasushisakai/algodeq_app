{% load staticfiles %}
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>

<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>

<script type="text/javascript" src="{% static "js/three.js" %}"></script>
<script type="text/javascript" src="{% static "js/tween.min.js" %}"></script>
<script type="text/javascript" src="{% static "js/OrbitControls.js" %}"></script>

<script type="text/javascript" src="{% static "model/Coefficients.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Axis.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Wall.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Floor.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Plan.js" %}"></script>

<form id="my_form" action="" method="post">
    {% csrf_token %}
    <input type="hidden" id="image" name="image" value="--">
    {#    <input type="submit" value="Send">#}
</form>

<div id="result"></div>


<script type="text/javascript">

//globals

var frameNo = 0;
var plans = [];
var geometryData, root;

var density = 1.4;
var record = false;


function initialize() {
    //document.body.style.backgroundColor = '#cccccc';

    setupThreeJS();
    setupWorld();
    //setupTween();
    setupEvents();

    //console.log(canvas.toDataURL().replace("data:image/png;base64,", ""));

    //looping
    requestAnimationFrame(function animate() {
        renderer.render(scene, camera);
        controls.update(clock.getDelta());

        var pace = 5;
        if (frameNo % pace == 0 && frameNo / pace < plans.length) {
            plans[frameNo / pace].toggleVisible();
        }

        if (frameNo < 3750 && record) {

            $.post("",
                    {
                        frame: zeroAdd(frameNo),
                        image: renderer.domElement.toDataURL().replace("data:image/png;base64,", ""),
                        csrfmiddlewaretoken: '{{ csrf_token}}'},

                    function (data, status) {
                        $("#result").html(data);
                    }
            )
                    .fail(function (xhr) {
                        console.log("Error: " + xhr.statusText);
                        alert("Error: " + xhr.statusText);
                    });
        }

        frameNo++;

        //TWEEN.update();
        requestAnimationFrame(animate);
    });
}

function setupThreeJS() {

    var CANVAS_WIDTH = window.innerWidth;
    var CANVAS_HEIGHT = window.innerHeight;
    CANVAS_WIDTH = 1920;
    CANVAS_HEIGHT = 1080;

    geometryData = [];
    {% for p in geomData %} geometryData.push({{ p.geometry | safe }});
    {% endfor %}

    root = Math.ceil(Math.sqrt(geometryData.length));

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(20, CANVAS_WIDTH / CANVAS_HEIGHT, unitSize * 3, 50000000);


    {#    camera.position = new THREE.Vector3(#}
    {#            (root * (unitLength + 250) / 2.0) + root * (unitLength + 250) * 2 + unitSize * 3,#}
    {#            root * (unitLength + 250) * 2 + unitSize * 3,#}
    {#            (root * (unitLength + 250) / 2.0) + root * (unitLength + 250) * 2 + unitSize * 3#}
    {#    );#}

    camera.position = new THREE.Vector3(
            (root * (unitLength + 250) * 0.75)  + unitSize *2.5,
            unitSize *2.5,
            (root * (unitLength + 250) * 0.75) + unitSize*2.5
    );

    clock = new THREE.Clock();
    controls = new THREE.OrbitControls(camera);
    {#    controls.target = new THREE.Vector3(#}
    {#            (root * (unitLength + 250) / 2.0) + root * (unitLength + 250) * 2,#}
    {#            root * (unitLength + 250) * 2,#}
    {#            (root * (unitLength + 250) / 2.0) + root * (unitLength + 250) * 2#}
    {#    );#}

    controls.target = new THREE.Vector3(
            (root * (unitLength + 250) * 0.75) ,
            0.0,
            (root * (unitLength + 250) * 0.75)
    )

    renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true});
    renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
    renderer.shadowMapEnabled = true;
    canvas = document.body.appendChild(renderer.domElement);
    canvas.style.width = CANVAS_WIDTH
    canvas.style.height = CANVAS_HEIGHT

    projector = new THREE.Projector();


}

function setupWorld() {
    //console.log(Plan.materialList.length);

    //////////////////////////////////////////////////////////////////////////////////////
    // light
    //////////////////////////////////////////////////////////////////////////////////////

    var ambient = new THREE.AmbientLight(0x959F9F);
    scene.add(ambient);


    var light = new THREE.DirectionalLight(0xcccccc, 1);
    light.position.set(
            (root * (unitLength + 250) * 0.75) + root * (unitLength + 250) + unitSize * 2.8,
            root * (unitLength + 250) + unitSize * 2.8,
            (root * (unitLength + 250) * 0.75) + root * (unitLength + 250) + unitSize * 2.8
    );
    light.castShadow = true;
    light.shadowMapWidth = 4096;
    light.shadowMapHeight = 4096;
    var d = 1000000;
    light.shadowCameraLeft = d;
    light.shadowCameraRight = -d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;
    light.shadowCameraNear = 100000;
    light.shadowCameraFar = 2500000;
    //light.shadowCameraVisible = true;
    light.shadowBias = 0.000001;
    light.shadowDarkness = 0.2;
    scene.add(light);

    //higher density value makes it sporadic

    var order = [];
    for (var i = 0; i < root * root * density * density; i++) order.push(i);

    shuffle(order);

    for (var j = 0; j < geometryData.length; j++) {

        //console.log(j);
        var plan = new Plan(
                geometryData[j],
                order[j] % Math.floor(root * density) * (unitLength + 250),
                Math.floor(order[j] / (root * density)) * (unitLength + 250)
        );

        plan.createEntity();
        plan.toggleVisible();
        plans.push(plan);
    }

    var bigplaneGeom = new THREE.CubeGeometry(Math.pow(unitLength + 250, 2), Math.pow(unitLength + 250, 2), 1000);

    var bigmat = new THREE.MeshPhongMaterial({color: 0xFFFFFF});
    var bigPlane = new THREE.Mesh(bigplaneGeom, bigmat);


    bigPlane.rotation.x = -90 * Math.PI / 180;
    bigPlane.position.x = (unitLength + 250) * root * density / 2.0 * 3;
    bigPlane.position.z = (unitLength + 250) * root * density / 2.0;
    bigPlane.position.y = -500;

    //bigPlane.recieveShadow = true;

    bigPlane.traverse(function (object) {
        object.receiveShadow = true;
    });
    scene.add(bigPlane);


    /////////////////////////////////////////////////////////////////////////////////////////
    // axis
    /////////////////////////////////////////////////////////////////////////////////////////
    var axis = new Axis(100000, 10);
    //axis.create();

}

function setupTween() {

    var position, target;
{#    var segment = 60 * 60 * 1000;#}

    var segment = 15 * 60 * 1000;


    //if (record)segment = segment * 100;

    position = new THREE.Vector3(
            (root * (unitLength + 250) * 0.75) + root * (unitLength + 250)*1.02 + unitSize * 2.8,
            root * (unitLength + 250)*1.02 + unitSize * 2.8,
            (root * (unitLength + 250) * 0.75) + root * (unitLength + 250)*1.02 + unitSize * 2.8
    );

    target = new THREE.Vector3(
            (root * (unitLength + 250) * 0.75) + root * (unitLength + 250)*1.02,
            root * (unitLength + 250)*1.02,
            (root * (unitLength + 250) * 0.75) + root * (unitLength + 250)*1.02
    );

    var tweenPos = new TWEEN.Tween(camera.position)
            .to({
                x: position.x,
                y: position.y,
                z: position.z
            }, segment)
            .easing(TWEEN.Easing.Sinusoidal.InOut);

    var tweenTarget = new TWEEN.Tween(controls.target)
            .to({
                x: target.x,
                y: target.y,
                z: target.z
            }, segment)
            .easing(TWEEN.Easing.Sinusoidal.InOut);

    tweenPos.start();
    tweenTarget.start();
}


function setupEvents() {
    renderer.domElement.addEventListener('mousemove', function (event) {

        event.preventDefault();

        var vector = new THREE.Vector3(
                renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
                -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
                0
        );

        projector.unprojectVector(vector, camera);

        var raycaster = new THREE.Raycaster(
                camera.position,
                vector.sub(camera.position).normalize()
        );

    });


    renderer.domElement.addEventListener('mousedown', function (event) {

        console.log(camera.position);
        console.log(controls.target);

        console.log($("#image").value);

    });

}

initialize();

</script>

</body>
</html>