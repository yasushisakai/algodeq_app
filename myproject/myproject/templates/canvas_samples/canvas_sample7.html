{% load staticfiles %}
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>

<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>


<script type="text/javascript" src="{% static "js/three.js" %}"></script>
<script type="text/javascript" src="{% static "js/tween.min.js" %}"></script>
<script type="text/javascript" src="{% static "js/OrbitControls.js" %}"></script>

<script type="text/javascript" src="{% static "model/Coefficients.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Axis.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Wall.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Floor.js" %}"></script>
<script type="text/javascript" src="{% static "model/class/Plan.js" %}"></script>

<form id="my_form" action="" method="post">
    {% csrf_token %}
    <input type="hidden" id="image" name="image" value="--">
    {#    <input type="submit" value="Send">#}
</form>

<div id="result"></div>


<script type="text/javascript">

//globals

var frameNo = 0;
var plans = [];
var geometryData, root;

var density = 1.4;
var record = false;

function initialize() {
    document.body.style.backgroundColor = '#cccccc';

    setupThreeJS();
    setupWorld();
    setupTween();
    setupEvents();

    //console.log(canvas.toDataURL().replace("data:image/png;base64,", ""));

    //looping
    requestAnimationFrame(function animate() {
        renderer.render(scene, camera);
        controls.update(clock.getDelta());

        var pace = 1;
        if (frameNo % pace == 0 && frameNo / pace < plans.length) {
            plans[frameNo / pace].toggleVisible();
        }

        if (frameNo < 3750 && record) {

            $.post("",
                    {
                        frame: zeroAdd(frameNo),
                        image: renderer.domElement.toDataURL().replace("data:image/png;base64,", ""),
                        csrfmiddlewaretoken: '{{ csrf_token}}'},

                    function (data, status) {
                        $("#result").html(data);
                    }
            )
                    .fail(function (xhr) {
                        console.log("Error: " + xhr.statusText);
                        alert("Error: " + xhr.statusText);
                    });
        }

        frameNo++;

        //TWEEN.update();
        requestAnimationFrame(animate);
    });
}

function setupThreeJS() {

    var CANVAS_WIDTH = window.innerWidth;
    var CANVAS_HEIGHT = window.innerHeight;
    CANVAS_WIDTH = 1920;
    CANVAS_HEIGHT = 1080;

    geometryData = [];
    {% for p in geomData %} geometryData.push({{ p.geometry | safe }});
    {% endfor %}

    root = Math.ceil(Math.sqrt(geometryData.length));

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(20, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 50000000);

{#    camera.position.x = (root * (unitLength + 250) / 2.0) + unitSize*3;#}
{#    camera.position.y = unitSize*3;#}
{#    camera.position.z = (root * (unitLength + 250) / 2.0) + unitSize*3;#}

    camera.position.x = (root * (unitLength + 250) / 2.0) + (root * (unitLength + 250) / 2.0);
    camera.position.y =(root * (unitLength + 250) / 2.0);
    camera.position.z = (root * (unitLength + 250) / 2.0) + (root * (unitLength + 250) / 2.0);

    //scene.add(camera);

    clock = new THREE.Clock();
    controls = new THREE.OrbitControls(camera);
    controls.target = new THREE.Vector3(
            (root * (unitLength + 250) / 2.0) + (root * (unitLength + 250) / 2.0)+unitSize,
            (root * (unitLength + 250) / 2.0)+unitSize,
            (root * (unitLength + 250) / 2.0) + (root * (unitLength + 250) / 2.0)+unitSize
    );

    renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true});
    renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
    renderer.shadowMapEnabled = true;
    canvas = document.body.appendChild(renderer.domElement);

    projector = new THREE.Projector();


}

function setupWorld() {

    //higher density value makes it sporadic

    var order = [];
    for (var i = 0; i < root * root * density * density; i++) order.push(i);

    shuffle(order);

    for (var j = 0; j < geometryData.length; j++) {

        //console.log(j);
        var plan = new Plan(
                geometryData[j],
                order[j] % Math.floor(root * density) * (unitLength + 250),
                Math.floor(order[j] / (root * density)) * (unitLength + 250)
        );


        //plan.create(entities);


        plan.createEntity();
        plan.toggleVisible();
        plans.push(plan);
    }

    var bigplaneGeom = new THREE.PlaneGeometry((unitLength + 250) * (root + 2) * density, (unitLength + 250) * (root + 2) * density, 1, 1);

    var bigmat = new THREE.MeshPhongMaterial({color: "0xEEEEEE"});
    var bigPlane = new THREE.Mesh(bigplaneGeom, bigmat);


    bigPlane.rotation.x = -90 * Math.PI / 180;
    bigPlane.position.x = (unitLength + 250) * root * density / 2.0;
    bigPlane.position.z = (unitLength + 250) * root * density / 2.0;
    bigPlane.position.y = -500;

    bigPlane.recieveShadow = true;
    //scene.add(bigPlane);

    //////////////////////////////////////////////////////////////////////////////////////
    // light
    //////////////////////////////////////////////////////////////////////////////////////

    var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;

    var ambient = new THREE.AmbientLight(0x474d4f);
    scene.add(ambient);

    {#    var light = new THREE.SpotLight(0xffffff, 1.1, 0, Math.PI*1.4, 2.0);#}
    {#    light.position.set(root * (unitLength + 250)*density, 50000, root * (unitLength + 250)*density);#}
    {#    light.target.position.set(root * (unitLength + 250)*density/2.0, 0, root * (unitLength + 250)*density/2.0);#}
    {##}
    {#    light.castShadow = true;#}
    {##}
    {#    light.shadowCameraNear = 7000;#}
    {#    light.shadowCameraFar = camera.far;#}
    {#    light.shadowCameraFov = 80;#}
    {##}
    {#    light.shadowCameraVisible = true;#}
    {##}
    {#    light.shadowBias = 0.000001;#}
    {#    light.shadowDarkness = 0.2;#}
    {##}
    {#    light.shadowMapWidth = SHADOW_MAP_WIDTH;#}
    {#    light.shadowMapHeight = SHADOW_MAP_HEIGHT;#}
    {##}
    {#    scene.add(light);#}

    var light = new THREE.DirectionalLight(0xf9f1c2, 1);
    light.position.set(500, 1500, 1000);
    light.castShadow = true;
    light.shadowMapWidth = 2048;
    light.shadowMapHeight = 2048;
    var d = 1000;
    light.shadowCameraLeft = d;
    light.shadowCameraRight = -d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;
    light.shadowCameraFar = 2500;
    scene.add(light);


    /////////////////////////////////////////////////////////////////////////////////////////
    // axis
    /////////////////////////////////////////////////////////////////////////////////////////
    var axis = new Axis(100000, 10);
    axis.create();

}

function setupTween() {

    var position, target;
    var segment = 1 * 60 * 1000;

    //if (record)segment = segment * 100;

    position = new THREE.Vector3(
            (root * (unitLength + 250) / 2.0) + root * (unitLength + 250)*2 + unitSize*3,
            root * (unitLength + 250)*2 + unitSize*3,
            (root * (unitLength + 250) / 2.0) + root * (unitLength + 250)*2 + unitSize*3
    );

    target = new THREE.Vector3(
            (root * (unitLength + 250) / 2.0) + root * (unitLength + 250)*2,
            root * (unitLength + 250)*2,
            (root * (unitLength + 250) / 2.0) + root * (unitLength + 250)*2
    );

    var tweenPos = new TWEEN.Tween(camera.position)
            .to({
                x: position.x,
                y: position.y,
                z: position.z
            }, segment)
            .easing(TWEEN.Easing.Sinusoidal.InOut);

    var tweenTarget = new TWEEN.Tween(controls.target)
            .to({
                x: target.x,
                y: target.y,
                z: target.z
            }, segment)
            .easing(TWEEN.Easing.Sinusoidal.InOut);

    tweenPos.start();
    tweenTarget.start();
}


function setupEvents() {
    renderer.domElement.addEventListener('mousemove', function (event) {

        event.preventDefault();

        var vector = new THREE.Vector3(
                renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
                -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
                0
        );

        projector.unprojectVector(vector, camera);

        var raycaster = new THREE.Raycaster(
                camera.position,
                vector.sub(camera.position).normalize()
        );

    });


    renderer.domElement.addEventListener('mousedown', function (event) {

        //event.preventDefault();

        console.log(camera.position);
        console.log(controls.target);
        //console.log(renderer.domElement.toDataURL().replace("data:image/png;base64,", ""));

        //$("#image").value = renderer.domElement.toDataURL().replace("data:image/png;base64,", "");

        console.log($("#image").value);

        for (var i = 0; i < plans.length; i++) {
            //plans[i].toggleVisible();
            //console.log(plans[i].visible);
        }

    });

}

initialize();

</script>

</body>
</html>